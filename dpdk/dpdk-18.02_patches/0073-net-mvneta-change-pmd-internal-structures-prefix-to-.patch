From ba40cdd32c324f9b0a72c393e12bb94bcc689d7e Mon Sep 17 00:00:00 2001
From: Zyta Szpak <zr@semihalf.com>
Date: Fri, 23 Mar 2018 07:39:12 +0100
Subject: [PATCH 73/74] net/mvneta: change pmd internal structures prefix to
 match overall prefix

---
 drivers/net/mvneta/mvneta_ethdev.c | 68 +++++++++++++++++++-------------------
 drivers/net/mvneta/mvneta_ethdev.h |  2 +-
 2 files changed, 35 insertions(+), 35 deletions(-)

diff --git a/drivers/net/mvneta/mvneta_ethdev.c b/drivers/net/mvneta/mvneta_ethdev.c
index 9adf90f..5644b2b 100644
--- a/drivers/net/mvneta/mvneta_ethdev.c
+++ b/drivers/net/mvneta/mvneta_ethdev.c
@@ -67,7 +67,7 @@ struct mvneta_ifnames {
  * In case it  was generated by application itself i.e: mbuf->port field is
  * 0xff then its released to software mempool.
  */
-struct neta_shadow_txq {
+struct mvneta_shadow_txq {
 	int head;           /* write index - used when sending buffers */
 	int tail;           /* read index - used when releasing buffers */
 	u16 size;           /* queue occupied size */
@@ -76,8 +76,8 @@ struct neta_shadow_txq {
 };
 
 
-struct neta_rxq {
-	struct neta_priv *priv;
+struct mvneta_rxq {
+	struct mvneta_priv *priv;
 	struct rte_mempool *mp;
 	int queue_id;
 	int port_id;
@@ -89,12 +89,12 @@ struct neta_rxq {
 };
 
 
-struct neta_txq {
-	struct neta_priv *priv;
+struct mvneta_txq {
+	struct mvneta_priv *priv;
 	int queue_id;
 	int port_id;
 	uint64_t bytes_sent;
-	struct neta_shadow_txq shadow_txqs[RTE_MAX_LCORE];
+	struct mvneta_shadow_txq shadow_txqs[RTE_MAX_LCORE];
 	int tx_deferred_start;
 };
 
@@ -112,7 +112,7 @@ static int mvneta_lcore_last;
  *   0 on success, negative error value otherwise.
  */
 static int
-mvneta_buffs_alloc(struct neta_priv *priv, struct neta_rxq *rxq, int num)
+mvneta_buffs_alloc(struct mvneta_priv *priv, struct mvneta_rxq *rxq, int num)
 {
 	struct rte_mbuf *mbufs[MRVL_NETA_TXD_MAX];
 	struct neta_buff_inf entries[MRVL_NETA_TXD_MAX];
@@ -199,7 +199,7 @@ mvneta_recv_buffs_free(struct neta_ppio_desc *desc, uint16_t num)
  */
 static inline void
 mvneta_sent_buffers_free(struct neta_ppio *ppio,
-		struct neta_shadow_txq *sq, int qid, int force)
+		struct mvneta_shadow_txq *sq, int qid, int force)
 {
 	struct neta_buff_inf *entry;
 	uint16_t nb_done = 0;
@@ -250,7 +250,7 @@ mvneta_sent_buffers_free(struct neta_ppio *ppio,
  *   Array of rx descriptors
  */
 static void
-mvneta_rx_queue_flush(struct neta_rxq *rxq, struct neta_ppio_desc *descs)
+mvneta_rx_queue_flush(struct mvneta_rxq *rxq, struct neta_ppio_desc *descs)
 {
 	int ret, num;
 
@@ -272,12 +272,12 @@ mvneta_rx_queue_flush(struct neta_rxq *rxq, struct neta_ppio_desc *descs)
  *     Pointer to tx queue structure
  */
 static void
-mvneta_tx_queue_flush(struct neta_txq *txq)
+mvneta_tx_queue_flush(struct mvneta_txq *txq)
 {
 	int i;
 
 	for (i = 0; i < RTE_MAX_LCORE; i++) {
-		struct neta_shadow_txq *sq =
+		struct mvneta_shadow_txq *sq =
 				&txq->shadow_txqs[i];
 
 		/* free the rest of them */
@@ -471,8 +471,8 @@ mvneta_prepare_proto_info(uint64_t ol_flags, uint32_t packet_type,
 static uint16_t
 mvneta_tx_pkt_burst(void *txq, struct rte_mbuf **tx_pkts, uint16_t nb_pkts)
 {
-	struct neta_txq *q = txq;
-	struct neta_shadow_txq *sq;
+	struct mvneta_txq *q = txq;
+	struct mvneta_shadow_txq *sq;
 	struct neta_ppio_desc descs[nb_pkts];
 	unsigned int core_id = rte_lcore_id();
 
@@ -565,7 +565,7 @@ mvneta_tx_pkt_burst(void *txq, struct rte_mbuf **tx_pkts, uint16_t nb_pkts)
 static uint16_t
 mvneta_rx_pkt_burst(void *rxq, struct rte_mbuf **rx_pkts, uint16_t nb_pkts)
 {
-	struct neta_rxq *q = rxq;
+	struct mvneta_rxq *q = rxq;
 	struct neta_ppio_desc descs[nb_pkts];
 	int i, ret, rx_done = 0;
 
@@ -646,7 +646,7 @@ mvneta_rx_pkt_burst(void *rxq, struct rte_mbuf **rx_pkts, uint16_t nb_pkts)
 static int
 mvneta_dev_configure(struct rte_eth_dev *dev)
 {
-	struct neta_priv *priv = dev->data->dev_private;
+	struct mvneta_priv *priv = dev->data->dev_private;
 
 	if (dev->data->dev_conf.rxmode.mq_mode != ETH_MQ_RX_NONE) {
 		RTE_LOG(INFO, PMD, "Unsupported RSS and rx multi queue mode %d\n",
@@ -756,7 +756,7 @@ mvneta_dev_infos_get(struct rte_eth_dev *dev __rte_unused,
 static int
 mvneta_mtu_set(struct rte_eth_dev *dev, uint16_t mtu)
 {
-	struct neta_priv *priv = dev->data->dev_private;
+	struct mvneta_priv *priv = dev->data->dev_private;
 	uint16_t mru = MRVL_NETA_MTU_TO_MRU(mtu);
 
 	if (mtu < ETHER_MIN_MTU || mru > MVNETA_PKT_SIZE_MAX) {
@@ -791,7 +791,7 @@ mvneta_mtu_set(struct rte_eth_dev *dev, uint16_t mtu)
 static int
 mvneta_dev_set_link_up(struct rte_eth_dev *dev)
 {
-	struct neta_priv *priv = dev->data->dev_private;
+	struct mvneta_priv *priv = dev->data->dev_private;
 	int ret;
 
 	if (!priv->ppio)
@@ -822,7 +822,7 @@ mvneta_dev_set_link_up(struct rte_eth_dev *dev)
 static int
 mvneta_dev_set_link_down(struct rte_eth_dev *dev)
 {
-	struct neta_priv *priv = dev->data->dev_private;
+	struct mvneta_priv *priv = dev->data->dev_private;
 
 	if (!priv->ppio)
 		return -EPERM;
@@ -855,8 +855,8 @@ mvneta_rx_queue_setup(struct rte_eth_dev *dev, uint16_t idx, uint16_t desc,
 		    const struct rte_eth_rxconf *conf __rte_unused,
 		    struct rte_mempool *mp)
 {
-	struct neta_priv *priv = dev->data->dev_private;
-	struct neta_rxq *rxq;
+	struct mvneta_priv *priv = dev->data->dev_private;
+	struct mvneta_rxq *rxq;
 	uint32_t min_size,
 		 max_rx_pkt_len = dev->data->dev_conf.rxmode.max_rx_pkt_len;
 
@@ -933,8 +933,8 @@ static int
 mvneta_tx_queue_setup(struct rte_eth_dev *dev, uint16_t idx, uint16_t desc,
 		    unsigned int socket, const struct rte_eth_txconf *conf)
 {
-	struct neta_priv *priv = dev->data->dev_private;
-	struct neta_txq *txq;
+	struct mvneta_priv *priv = dev->data->dev_private;
+	struct mvneta_txq *txq;
 
 	if (dev->data->tx_queues[idx]) {
 		rte_free(dev->data->tx_queues[idx]);
@@ -966,7 +966,7 @@ mvneta_tx_queue_setup(struct rte_eth_dev *dev, uint16_t idx, uint16_t desc,
 static void
 mvneta_tx_queue_release(void *txq)
 {
-	struct neta_txq *q = txq;
+	struct mvneta_txq *q = txq;
 
 	if (!q)
 		return;
@@ -986,7 +986,7 @@ mvneta_tx_queue_release(void *txq)
 static int
 mvneta_dev_start(struct rte_eth_dev *dev)
 {
-	struct neta_priv *priv = dev->data->dev_private;
+	struct mvneta_priv *priv = dev->data->dev_private;
 	char match[MVNETA_MATCH_LEN];
 	int ret = 0, i;
 
@@ -1004,7 +1004,7 @@ mvneta_dev_start(struct rte_eth_dev *dev)
 
 	/* Allocate buffers */
 	for (i=0; i < dev->data->nb_rx_queues; i++) {
-		struct neta_rxq *rxq = dev->data->rx_queues[i];
+		struct mvneta_rxq *rxq = dev->data->rx_queues[i];
 		ret = mvneta_buffs_alloc(priv, rxq, rxq->size);
 		if (ret) {
 			rte_free(rxq);
@@ -1020,7 +1020,7 @@ mvneta_dev_start(struct rte_eth_dev *dev)
 
 	/* start tx queues */
 	for (i = 0; i < dev->data->nb_tx_queues; i++) {
-		struct neta_txq *txq = dev->data->tx_queues[i];
+		struct mvneta_txq *txq = dev->data->tx_queues[i];
 
 		dev->data->tx_queue_state[i] = RTE_ETH_QUEUE_STATE_STARTED;
 
@@ -1053,13 +1053,13 @@ mvneta_dev_start(struct rte_eth_dev *dev)
 static void
 mvneta_dev_stop(struct rte_eth_dev *dev)
 {
-	struct neta_priv *priv = dev->data->dev_private;
+	struct mvneta_priv *priv = dev->data->dev_private;
 	int i;
 
 	mvneta_dev_set_link_down(dev);
 	RTE_LOG(INFO, PMD, "Flushing rx queues\n");
 	for (i = 0; i < dev->data->nb_rx_queues; i++) {
-		struct neta_rxq *rxq = dev->data->rx_queues[i];
+		struct mvneta_rxq *rxq = dev->data->rx_queues[i];
 		struct neta_ppio_desc descs[MRVL_NETA_RXD_MAX];
 
 		mvneta_rx_queue_flush(rxq, descs);
@@ -1067,7 +1067,7 @@ mvneta_dev_stop(struct rte_eth_dev *dev)
 
 	RTE_LOG(INFO, PMD, "Flushing tx queues\n");
 	for (i = 0; i < dev->data->nb_tx_queues; i++) {
-		struct neta_txq *txq = dev->data->tx_queues[i];
+		struct mvneta_txq *txq = dev->data->tx_queues[i];
 
 		mvneta_tx_queue_flush(txq);
 	}
@@ -1095,7 +1095,7 @@ mvneta_link_update(struct rte_eth_dev *dev, int wait_to_complete __rte_unused)
 	 * TODO
 	 * once MUSDK provides necessary API use it here
 	 */
-	struct neta_priv *priv = dev->data->dev_private;
+	struct mvneta_priv *priv = dev->data->dev_private;
 	struct ethtool_cmd edata;
 	struct ifreq req;
 	int ret, fd, link_up;
@@ -1171,10 +1171,10 @@ static const struct eth_dev_ops mvneta_ops = {
  * @return
  *   Pointer to the newly allocated private device structure.
  */
-static struct neta_priv *
+static struct mvneta_priv *
 mvneta_priv_create(const char *dev_name)
 {
-	struct neta_priv *priv;
+	struct mvneta_priv *priv;
 
 	priv = rte_zmalloc_socket(dev_name, sizeof(*priv), 0, rte_socket_id());
 	if (!priv)
@@ -1197,7 +1197,7 @@ mvneta_eth_dev_create(struct rte_vdev_device *vdev, const char *name)
 {
 	int ret, fd = socket(AF_INET, SOCK_DGRAM, 0);
 	struct rte_eth_dev *eth_dev;
-	struct neta_priv *priv;
+	struct mvneta_priv *priv;
 	struct ifreq req;
 
 	eth_dev = rte_eth_dev_allocate(name);
@@ -1257,7 +1257,7 @@ static void
 mvneta_eth_dev_destroy(const char *name)
 {
 	struct rte_eth_dev *eth_dev;
-	struct neta_priv *priv;
+	struct mvneta_priv *priv;
 
 	eth_dev = rte_eth_dev_allocated(name);
 	if (!eth_dev)
diff --git a/drivers/net/mvneta/mvneta_ethdev.h b/drivers/net/mvneta/mvneta_ethdev.h
index 9bd0c75..722719c 100644
--- a/drivers/net/mvneta/mvneta_ethdev.h
+++ b/drivers/net/mvneta/mvneta_ethdev.h
@@ -57,7 +57,7 @@
 #define MRVL_NETA_MRU_TO_MTU(mru) \
 	((mru) - MV_MH_SIZE - ETHER_HDR_LEN + ETHER_CRC_LEN)
 
-struct neta_priv {
+struct mvneta_priv {
 	/* Hot fields, used in fast path. */
 	struct neta_ppio	*ppio;    /**< Port handler pointer */
 
-- 
2.7.4

