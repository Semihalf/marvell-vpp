From 7238cb8e1ad5064c53a5a544a3b43f9385403c88 Mon Sep 17 00:00:00 2001
From: Zyta Szpak <zr@semihalf.com>
Date: Thu, 22 Feb 2018 12:53:38 +0100
Subject: [PATCH 15/74] mrvlna: add txq setup

---
 drivers/net/mrvlna/mrvlna_ethdev.c | 95 +++++++++++++++++++++++++++++++++-----
 drivers/net/mrvlna/mrvlna_ethdev.h |  6 +--
 2 files changed, 87 insertions(+), 14 deletions(-)

diff --git a/drivers/net/mrvlna/mrvlna_ethdev.c b/drivers/net/mrvlna/mrvlna_ethdev.c
index 2c198f0..80914b7 100644
--- a/drivers/net/mrvlna/mrvlna_ethdev.c
+++ b/drivers/net/mrvlna/mrvlna_ethdev.c
@@ -76,6 +76,26 @@ struct mrvlna_ifnames {
 	int idx;
 };
 
+/*
+ * To use buffer harvesting based on loopback port shadow queue structure
+ * was introduced for buffers information bookkeeping.
+ *
+ * Before sending the packet, related buffer information is
+ * stored in shadow queue. After packet is transmitted no longer used
+ * packet buffer is released back to it's original hardware pool,
+ * on condition it originated from interface.
+ * In case it  was generated by application itself i.e: mbuf->port field is
+ * 0xff then its released to software mempool.
+ */
+struct neta_shadow_txq {
+	int head;           /* write index - used when sending buffers */
+	int tail;           /* read index - used when releasing buffers */
+	u16 size;           /* queue occupied size */
+	u16 num_to_release; /* number of buffers sent, that can be released */
+	struct buff_release_entry ent[MRVL_NETA_TX_SHADOWQ_SIZE]; /* q entries */
+};
+
+
 struct neta_rxq {
 	struct neta_priv *priv;
 	struct rte_mempool *mp;
@@ -86,6 +106,15 @@ struct neta_rxq {
 	uint64_t drop_mac;
 };
 
+struct neta_txq {
+	struct neta_priv *priv;
+	int queue_id;
+	int port_id;
+	uint64_t bytes_sent;
+	struct neta_shadow_txq shadow_txqs[RTE_MAX_LCORE];
+	int tx_deferred_start;
+};
+
 static int mrvlna_dev_num;
 static int mrvlna_lcore_first;
 static int mrvlna_lcore_last;
@@ -390,6 +419,50 @@ mrvlna_rx_queue_release(void *rxq)
 	rte_free(q);
 }
 
+/**
+ * DPDK callback to configure the transmit queue.
+ *
+ * @param dev
+ *   Pointer to Ethernet device structure.
+ * @param idx
+ *   Transmit queue index.
+ * @param desc
+ *   Number of descriptors to configure in the queue.
+ * @param socket
+ *   NUMA socket on which memory must be allocated.
+ * @param conf
+ *   Tx queue configuration parameters.
+ *
+ * @return
+ *   0 on success, negative error value otherwise.
+ */
+static int
+mrvlna_tx_queue_setup(struct rte_eth_dev *dev, uint16_t idx, uint16_t desc,
+		    unsigned int socket, const struct rte_eth_txconf *conf)
+{
+	struct neta_priv *priv = dev->data->dev_private;
+	struct neta_txq *txq;
+
+	if (dev->data->tx_queues[idx]) {
+		rte_free(dev->data->tx_queues[idx]);
+		dev->data->tx_queues[idx] = NULL;
+	}
+
+	txq = rte_zmalloc_socket("txq", sizeof(*txq), 0, socket);
+	if (!txq)
+		return -ENOMEM;
+
+	txq->priv = priv;
+	txq->queue_id = idx;
+	txq->port_id = dev->data->port_id;
+	txq->tx_deferred_start = conf->tx_deferred_start;
+	dev->data->tx_queues[idx] = txq;
+
+	priv->ppio_params.outqs_params.outqs_params[idx].size = desc;
+
+	return 0;
+}
+
 static const struct eth_dev_ops mrvlna_ops = {
 	.dev_configure = mrvlna_dev_configure,
 //	.dev_start = ,
@@ -412,7 +485,7 @@ static const struct eth_dev_ops mrvlna_ops = {
 //	.tx_queue_stop = ,
 	.rx_queue_setup = mrvlna_rx_queue_setup,
 	.rx_queue_release = mrvlna_rx_queue_release,
-//	.tx_queue_setup = ,
+	.tx_queue_setup = mrvlna_tx_queue_setup,
 //	.tx_queue_release = ,
 };
 
@@ -431,7 +504,7 @@ mrvlna_priv_create(const char *dev_name)
 	struct neta_bpool_params bpool_params;
 	char match[MRVLNA_MATCH_LEN];
 	struct neta_priv *priv;
-	int ret;// bpool_bit;
+//	int ret;// bpool_bit;
 
 	priv = rte_zmalloc_socket(dev_name, sizeof(*priv), 0, rte_socket_id());
 	if (!priv)
@@ -452,12 +525,12 @@ mrvlna_priv_create(const char *dev_name)
 	memset(&bpool_params, 0, sizeof(bpool_params));
 	bpool_params.match = match;
 	bpool_params.buff_len = MRVLNA_PKT_SIZE_MAX + MRVLNA_PKT_EFFEC_OFFS;
-	ret = neta_bpool_init(&bpool_params, &priv->bpool);
-	if (ret) {
-		RTE_LOG(ERR, PMD, "Failed to init bpool!\n");
-	//	goto out_clear_bpool_bit;
-		goto out_free_priv;
-	}
+//	ret = neta_bpool_init(&bpool_params, &priv->bpool);
+//	if (ret) {
+//		RTE_LOG(ERR, PMD, "Failed to init bpool!\n");
+//	//	goto out_clear_bpool_bit;
+//		goto out_free_priv;
+//	}
 
 //	priv->ppio_params.type = PP2_PPIO_T_NIC;
 //	rte_spinlock_init(&priv->lock);
@@ -465,9 +538,9 @@ mrvlna_priv_create(const char *dev_name)
 	return priv;
 //out_clear_bpool_bit:
 //	used_bpools[priv->pp_id] &= ~(1 << priv->bpool_bit);
-out_free_priv:
-	rte_free(priv);
-	return NULL;
+//out_free_priv:
+//	rte_free(priv);
+//	return NULL;
 }
 
 /**
diff --git a/drivers/net/mrvlna/mrvlna_ethdev.h b/drivers/net/mrvlna/mrvlna_ethdev.h
index 0ca1b30..6d4ebbd 100644
--- a/drivers/net/mrvlna/mrvlna_ethdev.h
+++ b/drivers/net/mrvlna/mrvlna_ethdev.h
@@ -72,9 +72,9 @@
 
 #define MRVL_NETA_DEFAULT_TC 0
 
-///** Maximum number of descriptors in shadow queue. Must be power of 2 */
-//#define MRVL_NETA_TX_SHADOWQ_SIZE MRVL_NETA_TXD_MAX
-//
+/** Maximum number of descriptors in shadow queue. Must be power of 2 */
+#define MRVL_NETA_TX_SHADOWQ_SIZE MRVL_NETA_TXD_MAX
+
 ///** Shadow queue size mask (since shadow queue size is power of 2) */
 //#define MRVL_NETA_TX_SHADOWQ_MASK (MRVL_NETA_TX_SHADOWQ_SIZE - 1)
 //
-- 
2.7.4

